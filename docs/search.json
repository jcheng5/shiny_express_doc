[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny Express",
    "section": "",
    "text": "Shiny Express is a new way of writing Shiny apps that is intended to be easier to learn and quicker to write. We think that writing Shiny Express is comparable to Streamlit in terms of how easily you can create an app, but Shiny Express does not limit you the way that Streamlit does – there is a much higher ceiling to what you can do with Shiny Express.\nShiny Express is still Shiny, just with a simpler syntax. It is currently available in the development version of Shiny on GitHub, but not on the released version on PyPI."
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "Shiny Express",
    "section": "Quickstart",
    "text": "Quickstart\nThe best way to introduce Shiny Express is by example. Here is a simple “Hello World” app:\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n\nfrom shiny import ui, render\nfrom shiny.express import input\n\nui.input_slider(\"n\", \"N\", min=1, max=50, value=30)\n\n@render.text\ndef txt():\n    return f\"Hello! n*2 is {input.n() * 2}.\"\nThe slider input comes from ui.input_slider(), and the text output is a function that’s decorated with @render.text and returns a string.\nIf you’ve seen traditional Shiny applications (we’ll call them “Classic” for now), you’ll notice some important differences. Here’s the same app written in Shiny Classic form:\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 300\nfrom shiny import App, ui, render\n\napp_ui = ui.page_fillable(\n    ui.input_slider(\"n\", \"N\", min=1, max=50, value=30),\n    ui.output_text_verbatim(\"txt\"),\n)\n\ndef server(input, output, session):\n    @render.text\n    def txt():\n        return f\"Hello! n*2 is {input.n() * 2}.\"\n\napp = App(app_ui, server)\nNot only is there significantly less code in the Express version, but there are fewer concepts to (mis)understand or be intimidated by.\nHere’s what’s different in the Classic app:\n\nThe UI is created explicitly in a variable named app_ui, using nested calls to UI component functions.\nThere is an explicitly defined server function. (This function is executed once for each browser session that connects to the app).\nThe text output is created with output_text_verbatim(\"txt\"). For Shiny Express mode, we didn’t have to create that output – it’s created automatically when it sees the @render.text.\nThere is an explicitly created object named app, which is a shiny.App() object.\n\nShiny Express apps do a these things implicitly, instead of requiring you to do them explicitly."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Shiny Express",
    "section": "Installation",
    "text": "Installation\nAs of this writing, Shiny Express has been merged to main but not published to PyPI. It can also be used on shinylive.io. (For embedding Shinylive applications in Quarto documents, it is technically possible, as this document shows, but it is a manual process as of this writing.)\nTo run these examples, you can use shinylive.io, or you can install shiny and htmltools from GitHub:\npip install git+https://github.com/posit-dev/py-htmltools\npip install git+https://github.com/posit-dev/py-shiny"
  },
  {
    "objectID": "index.html#basic-app-with-a-plot",
    "href": "index.html#basic-app-with-a-plot",
    "title": "Shiny Express",
    "section": "Basic app with a plot",
    "text": "Basic app with a plot\nThe example above shows a very bare-bones Shiny application. Here’s one that’s a little more sophisticated, with a layout component (a sidebar), and a plot.\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 300\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom shiny import ui, render\nfrom shiny.express import input, layout\n\nnp.random.seed(0)\ndata = np.random.randn(10000)\n\nwith layout.sidebar():\n    ui.input_slider(\"num_bins\", \"Number of Bins\", min=1, max=50, value=30)\n\n@render.plot\ndef plot():\n    plt.hist(data, bins=input.num_bins())\nContrast the Shiny Express code above with the Shiny Classic equivalent below:\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n#| viewerHeight: 300\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom shiny import App, ui, render\n\nnp.random.seed(0)\ndata = np.random.randn(10000)\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_slider(\"num_bins\", \"Number of Bins\", min=1, max=50, value=30),\n    ),\n    ui.output_plot(\"plot\"),\n)\n\ndef server(input, output, session):\n    @render.plot\n    def plot():\n        plt.hist(data, bins=input.num_bins())\n\napp = App(app_ui, server)\nSome things to notice:\n\nIn the Classic app, we first used the page-level component ui.page_sidebar(), and nested inside of that, a ui.sidebar().\nIn the Express app, we created a sidebar using with layout.sidebar(). (Under the hood, this component tells Shiny Express that the parent page component is ui.page_sidebar()).\nNotice that with the Express app used express.layout.sidebar(), while the Classic app used ui.sidebar(). These are not quite the same thing – the function in express.layout is actually a special wrapper for the function in ui, which can be used as a context manager."
  },
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "Shiny Express",
    "section": "Motivation",
    "text": "Motivation\nShiny Classic applications With Shiny Express, our hope is to introduce a gentler simplicity/power tradeoff, that is nearly as easy as Streamlit but 1) not nearly as limited, and 2) leads you most of the way to Shiny Classic."
  },
  {
    "objectID": "index.html#caveats",
    "href": "index.html#caveats",
    "title": "Shiny Express",
    "section": "Caveats",
    "text": "Caveats\nWhile we believe that Shiny Express will turn out to be an effective tool for those new to Shiny, we also believe that it will not be appropriate for all use cases–hence our continuing belief in the Shiny Classic model. A recurring theme you will find in the finer points below is that Shiny Express is easier to write but harder to manipulate and reason about, while Shiny Classic demands more up-front learning and some small inconveniences in return for being easier to read and reason about as your apps get larger.\nWe also want to acknowledge the inherent risk of introducing a second (or depending on how you count, also a third and fourth!) way of writing Shiny apps. One risk is that Shiny Express will lead users into a learning cul-de-sac that is then harder to grow out of (and into Shiny Classic) than if they had just learned Shiny in the first place–as we see Streamlit users cling to it long after they have left the domain where Streamlit works well. Another risk is that having two ways of doing things is just going to be confusing (see Panel, or on the mostly-positive side, Matplotlib)."
  },
  {
    "objectID": "index.html#differences-between-express-and-classic",
    "href": "index.html#differences-between-express-and-classic",
    "title": "Shiny Express",
    "section": "Differences between Express and Classic",
    "text": "Differences between Express and Classic\nThe main differences between Shiny Express and Classic are the following:\n\nThere is no separation between UI and server code. The UI and server code is mixed together.\nIn Shiny Express, UI components can be nested by writing with layout.xx(), where layout.xx() is a component that can contain other UI elements.\nShiny Express apps have from shiny.express import ..., import shiny.express, or from shiny import express. The presence of any of these statements tells Shiny that the app should be run in Express mode.\n\n\nNo separation between UI and server code\nIn Classic, UI and server logic are declared separately, with the UI containing ui.output_xxx objects to indicate where each output goes and the server containing the logic indicating what each output is.\n#| standalone: true\n#| components: [editor, viewer]\n# Classic\nfrom shiny import ui, render, reactive, App\nfrom datetime import datetime\n\napp_ui = ui.page_fillable(\n    ui.h1(\"Title\"),\n    ui.output_text_verbatim(\"greeting\"),\n)\n\ndef server(input, output, session):\n    @reactive.Calc\n    def time():\n        reactive.invalidate_later(1)\n        return datetime.now()\n\n    @render.text\n    def greeting():\n        return f\"Hello, world!\\nIt's currently {time()}.\"\n\napp = App(app_ui, server)\nIn Shiny Express, the top level of the Python file can contain both UI expressions and server declarations, in any order. By default, declaring a render function causes it to appear right in that spot.\n#| standalone: true\n#| components: [editor, viewer]\n# Express\nfrom shiny import ui, render, reactive, App\nimport shiny.express\nfrom datetime import datetime\n\nui.h1(\"Title\")\n\n@reactive.Calc\ndef time():\n    reactive.invalidate_later(1)\n    return datetime.now()\n\n@render.text\ndef greeting():\n    return f\"Hello, world!\\nIt's currently {time()}.\"\nNotice how greeting in this app does not have a corresponding call to output_text_verbatim(\"greeting\"). This is because in Shiny Express, the render functions automatically invoke that output function and add it to the page – no need to do it manually.\n\nExpress advantages:\n\nIt’s nice for beginners not to have to learn about the difference between UI and server.\nAvoids having to write code in two different places for a single output, and having to make the IDs match up.\nNo need to write nested function declarations (i.e. functions inside the server function), which can be surprising to Python programmers.\n\n\n\nClassic advantages:\n\nUI structure is clearer to read, reorder, and restructure. This advantage grows as app UIs grow larger.\nExplicit server function declaration gave us a natural place to put code that should only execute at startup (top level) versus for each session (server function body).\n\n\n\n\nLayout components using with layout.xx()\nWe’ll use the term layout components to refer to components that contain other components as children. For example, a sidebar is a layout component because it contains other components, whereas a input_text() is not a layout component because it has no children.\nIn Shiny Classic, all components are available from the ui submodule, for example, ui.sidebar(), and ui.input_text(). You might create a simple app UI like this:\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n# Classic\nfrom shiny import ui, render, App\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_text(\"txt_in\", \"Type something here:\"),\n        fg=\"white\",\n        bg=\"black\",\n    ),\n    ui.card(\n        ui.output_text_verbatim(\"result\"),\n    )\n)\n\ndef server(input, output, session):\n    @render.text\n    def result():\n        return f\"You entered '{input.txt_in()}'.\"\n\napp = App(app_ui, server)\nIn Express apps, there are the following differences:\n\nThere’s no need to call page_sidebar() – simply using ui.sidebar() tells Shiny to use page_sidebar().\nInstead of ui.sidebar(), you use with layout.sidebar(). You still call layout.sidebar() with the named arguments, like fg and bg. The unnamed arguments will be used as children to the sidebar.\nYou can even put the server code inside of the with statement.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: vertical\n# Express\nfrom shiny import ui, render, App\nfrom shiny.express import input, layout\n\nwith layout.sidebar(fg=\"white\", bg=\"black\"):\n    ui.input_text(\"txt_in\", \"Type something here:\")\n\nwith layout.card():\n    @render.text\n    def result():\n        return f\"You entered '{input.txt_in()}'.\"\nMost of the layout component functions from shiny.ui have corresponding functions in shiny.express.layout. If you find that Express lacks a layout component that you need, please let us know.\nShiny Express layout functions can be nested, as in:\nwith layout.row():\n    with layout.column(6):\n        # Content here...\nIn an Express app, you can also still use Classic layout components, like this:\nui.row(\n    ui.column(\n        ...,\n        width=6\n    )\n)\nThis can be useful in some cases, like if you’re writing a function that returns some UI.\n\n\nPage-level containers\nIn a Classic app, the UI always has a top-level page_ container, like page_fluid(), page_fillable(), or page_sidebar().\nIn an Express app, there is also a top-level page_ container, but the user does not need to call the function explicitly.\nThe default page container is page_fillable(). However, if you call with layout.sidebar(), then it will automatically set the page container to page_sidebar().\nYou can set the page-level container explicitly by calling layout.set_page(). For example, suppose you want to use page_fixed() instead of page_fillable() (because you want flowing content with a constrained width). You would simply call this at the top of your app:\nlayout.set_page(layout.page_fixed())\n\n\nList of layout components\nThese are the components currently available in express.layout. Each of them has a counterpart in ui.\n\nsidebar\nlayout_column_wrap\ncolumn\nrow\ncard\naccordion\naccordion_panel\nnavset_tab\nnavset_card_tab\nnav\np\ndiv\nspan\npre"
  },
  {
    "objectID": "index.html#deploying-shiny-express-apps",
    "href": "index.html#deploying-shiny-express-apps",
    "title": "Shiny Express",
    "section": "Deploying Shiny Express apps",
    "text": "Deploying Shiny Express apps\nTo deploy Shiny Express apps on a Connect server or shinyapps.io, you will need to install a development version of the rsconnect-python package:\npip install git+https://github.com/rstudio/rsconnect-python\nYou will also need to provide a requirements.txt file which tells the server to install htmltools and shiny from GitHub:\n# requirements.txt\nhtmltools@git+https://github.com/posit-dev/py-htmltools.git@main\nshiny@git+https://github.com/posit-dev/py-shiny.git@main\nThen deploy the app as usual. If you are in the directory containing the app, use the following command, replacing &lt;server name&gt; with the nickname for your server.\nrsconnect deploy shiny . -n &lt;server name&gt;"
  }
]